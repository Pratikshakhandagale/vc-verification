"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var library_1 = require("@zxing/library");
var HTMLCanvasElementLuminanceSource = /** @class */ (function (_super) {
    __extends(HTMLCanvasElementLuminanceSource, _super);
    function HTMLCanvasElementLuminanceSource(canvas) {
        var _this = _super.call(this, canvas.width, canvas.height) || this;
        _this.canvas = canvas;
        _this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);
        return _this;
    }
    HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData = function (canvas) {
        var ctx = canvas.getContext('2d');
        if (!ctx) {
            throw new Error('Could not get the canvas context.');
        }
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
    };
    HTMLCanvasElementLuminanceSource.toGrayscaleBuffer = function (imageBuffer, width, height) {
        var grayscaleBuffer = new Uint8ClampedArray(width * height);
        for (var i = 0, j = 0, length = imageBuffer.length; i < length; i += 4, j++) {
            var gray = void 0;
            var alpha = imageBuffer[i + 3];
            // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent
            // black (0 alpha, and then 0 RGB). They are often used, of course as the "white" area in a
            // barcode image. Force any such pixel to be white:
            if (alpha === 0) {
                gray = 0xFF;
            }
            else {
                var pixelR = imageBuffer[i];
                var pixelG = imageBuffer[i + 1];
                var pixelB = imageBuffer[i + 2];
                // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),
                // (306*R) >> 10 is approximately equal to R*0.299, and so on.
                // 0x200 >> 10 is 0.5, it implements rounding.
                // tslint:disable-next-line:no-bitwise
                gray = (306 * pixelR +
                    601 * pixelG +
                    117 * pixelB +
                    0x200) >> 10;
            }
            grayscaleBuffer[j] = gray;
        }
        return grayscaleBuffer;
    };
    /**
     * Crops the source in the way you want.
     *
     * @param left Left offset.
     * @param top Top offset.
     * @param width Crop area width.
     * @param height Crop are height.
     */
    HTMLCanvasElementLuminanceSource.prototype.crop = function (left, top, width, height) {
        this.crop(left, top, width, height);
        return this;
    };
    HTMLCanvasElementLuminanceSource.prototype.getRow = function (y, row) {
        if (y < 0 || y >= this.getHeight()) {
            throw new library_1.IllegalArgumentException('Requested row is outside the image: ' + y);
        }
        var width = this.getWidth();
        var start = y * width;
        if (row === null) {
            return this.buffer.slice(start, start + width);
        }
        if (row.length < width) {
            row = new Uint8ClampedArray(width);
        }
        // The underlying raster of image consists of bytes with the luminance values
        // TODO: can avoid set/slice?
        row.set(this.buffer.slice(start, start + width));
        return row;
    };
    HTMLCanvasElementLuminanceSource.prototype.getMatrix = function () {
        return this.buffer;
    };
    /**
     * Indicates if crop is supported by this class.
     */
    HTMLCanvasElementLuminanceSource.prototype.isCropSupported = function () {
        return true;
    };
    /**
     * Inverts the luminance source.
     */
    HTMLCanvasElementLuminanceSource.prototype.invert = function () {
        return new library_1.InvertedLuminanceSource(this);
    };
    /**
     * This is always true, since the image is a gray-scale image.
     */
    HTMLCanvasElementLuminanceSource.prototype.isRotateSupported = function () {
        return true;
    };
    /**
     * Returns the canvas element.
     */
    HTMLCanvasElementLuminanceSource.prototype.getTempCanvasElement = function () {
        if (!this.tempCanvasElement) {
            var tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');
            tempCanvasElement.style.width = this.canvas.width + "px";
            tempCanvasElement.style.height = this.canvas.height + "px";
            this.tempCanvasElement = tempCanvasElement;
        }
        return this.tempCanvasElement;
    };
    /**
     * Rotates the image.
     *
     * @param angle Angle in integer degress to rotate the image.
     */
    HTMLCanvasElementLuminanceSource.prototype.rotate = function (angle) {
        var tempCanvasElement = this.getTempCanvasElement();
        var tempContext = tempCanvasElement.getContext('2d');
        if (!tempContext) {
            throw new Error('Could not get the current canvas context.');
        }
        tempContext.rotate(angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS);
        tempContext.drawImage(this.canvas, 0, 0);
        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);
        return this;
    };
    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;
    return HTMLCanvasElementLuminanceSource;
}(library_1.LuminanceSource));
exports.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;
